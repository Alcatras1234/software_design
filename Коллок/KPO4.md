# Подготовка к коллоку КПО 4 модуль
## Продукт бай Даниал Бакиров

# Сеть 
### Что такое WebSocket и как он отличается от HTTP? В каких случаях целесообразно использовать WebSocket? Опишите процесс установления WebSocket соединения и его закрытия.
* Websoket - это протокол связи обеспечивающий двухстороннее соединение между клиентом и сервером через одно соединение TCP. В отличии от HTTP,
#### В каких случаях целоесообразно использовать?
* Websocket позволяет обмениваться данными в режиме реального времени. Поддерживаеь постоянное соединение и позволяет обмениваться даныыми без повторного установления соединения. 

* Целесообразно использовать в ИГРАХ, ТРАНСЛЯЦИЯХ, ЧАТЫ И МЕССЕНДЖЕРЫ, ПРИЛОЖЕНИЯ ДЛЯ СОВМЕСТНОЙ РАБОТЫ.
#### Опишите процесс установления WebSocket соединения и его закрытия.

* Инициация соединения: Клиент отправляет HTTP запрос с методом GET и заголовком Upgrade, указывающим на желание перейти на протокол WebSocket. \
  * Подтверждение от сервера: Если сервер поддерживает WebSocket и согласен на  установление соединения, он отвечает с кодом статуса 101 Switching Protocols, подтверждая обновление протокола. 
  * Установление постоянного соединения: После подтверждения от сервера, соединение считается установленным, и обе стороны могут начинать обмен данными. 
  * Закрытие: Закрытие клиентом: Клиент отправляет фрейм закрытия, чтобы инициировать процесс закрытия соединения.  
  * Закрытие сервером: Сервер отправляет фрейм закрытия, чтобы уведомить клиента о необходимости закрытия соединения.

### Что такое STOMP и как он работает поверх WebSocket? Каковы преимущества использования STOMP? Какие основные команды STOMP вы знаете и для чего они используются?

#### Что такое STOMP и как он работает поверх WebSocket?
* STOMP (Simple/Streaming Text Oriented Messaging Protocol) — это простой текстовый протокол обмена сообщениями, предназначенный для взаимодействия между клиентам и серверорм.  STOMP предоставляет стандартизированный набор команд и формат сообщений, который можно использовать поверх различных транспортных протоколов, включая WebSocket.
  * Установка WebSocket соединения
  * Взаимодействие через STOMP.  После установления WebSocket соединения клиент и сервер начинают обмениваться STOMP кадрами (frames) через это соединение.
  * Каждый STOMP кадр состоит из команды, заголовков и тела сообщения. Эти кадры передаются как текстовые данные через WebSocket соединение.
#### Преимущества STOMP
   * Легкость реализации
   * Поддержка брокеров сообщений RabbitMQ, ActiveMQ
   * Поддержка различных транспортных протоколов
   * STOMP поддерживает модель подписок и рассылок, что позволяет создавать асинхронные приложения с эффективной передачей сообщений.
#### Какие основные команды STOMP вы знаете и для чего они используются?
   * CONNECT - установить соединение 
   * SEND - отправить сообщение
   * SUBSCRIBE - подписаться на канал
   * DISCONNECT - завершить соединение

### Дайте определение GraphQL. Какие проблемы он решает по сравнению с RESTful API? Опишите основные типы запросов в GraphQL и приведите примеры каждого из них.
#### Дайте определение GraphQL
 * это язык запросов для API и среда выполнения, которая исполняет эти запросы с использованием данных из существующих систем.
####  Какие проблемы он решает по сравнению с RESTful API? 
* Избыточность данных (Over-fetching): В RESTful API клиенты часто получают больше данных, чем им нужно, так как каждый эндпоинт возвращает предопределенный набор данных. GraphQL позволяет клиентам запрашивать только те поля, которые им необходимы.
* Недостаток данных (Under-fetching): RESTful API может потребовать выполнения нескольких запросов для получения связанных данных. GraphQL позволяет запрашивать все необходимые данные за один запрос.
* GraphQL предоставляет клиентам возможность динамически формировать запросы, запрашивая только необходимые данные.
* Единая точка входа: GraphQL предоставляет единую точку входа для доступа к различным данным и ресурсам, упрощая интеграцию и уменьшая количество запросов.
#### Опишите основные типы запросов в GraphQL и приведите примеры каждого из них.
* В GraphQL существует три основных типа операций: query, mutation и subscription
  * Query - Запросы (queries) используются для получения данных. Они аналогичны GET запросам в RESTful API.
  ```
  query {
    user(id: "1") {
      id
      name
      email
    }
  }

  ```
  * Мутации (mutations) используются для изменения данных. Они аналогичны POST, PUT, DELETE запросам в RESTful API.
  ```
  mutation {
    createUser(input: {name: "John Doe", email: "john.doe@example.com"}) {
      id
      name
      email
    }
  }
  ```
 * Subscription Подписки (subscriptions) используются для получения данных в реальном времени. Они позволяют клиентам подписываться на изменения данных.
  ```
subscription {
  messageAdded(channelId: "1") {
    id
    content
    user {
      id
      name
    }
  }
}
  ```

### Какие недостатки и вызовы могут возникнуть при использовании GraphQL? В каких случаях вы бы рекомендовали использовать REST API вместо GraphQL и почему?

* Проблемы производительности:\
  Глубокие и сложные запросы: Клиенты могут создавать запросы с глубокой вложенностью, что может негативно сказаться на производительности сервера. \
  Перегрузка сервера: Возможность клиентам запрашивать большие объемы данных может привести к высокой нагрузке на сервер.
* Проблемы с кешированием: \
Кеширование: В REST API кеширование можно легко настроить на уровне HTTP, тогда как в GraphQL необходимо внедрять более сложные механизмы кеширования, так как каждый запрос может быть уникальным.
* Серверная часть: \
Разработка и поддержка GraphQL сервера может быть сложнее, чем RESTful API. Необходимо обеспечить безопасность, контроль доступа и оптимизацию запросов. \
Типизация: Нужна четкая схема типов, что требует дополнительных усилий по проектированию и поддержке.
* Более низкая интерпретируемость: \ 
Запросы и ответы GraphQL могут быть более сложными для понимания и отладки, чем в REST API.

#### В каких случаях вы бы рекомендовали использовать REST API вместо GraphQL и почему?
* Не нужна гибкость GraphQL
* Происходит работа с языками и фреймворками, не поддерживающие GraphQL
* Кеширование: HTTP протокол предоставляет встроенные возможности для кеширования GET запросов, что может существенно повысить производительность.
* У вас есть ограничения на обучение или ресурсы для реализации GraphQL.

### Протоколы прикладного уровня: HTTP/1.1 и HTTP/2

#### HTTP / 1.1
* Текстовый протокол, запросы и ответы передаются в текстовом формате
* Поддержка keep-alive - поддержка постоянных соединений, что позволяет использовать одно соединение для передачи нескольких запросов и ответов
* Кэширование 
* Компресия данных - поддержка сжития данных, для уменьшения объема передаваемых данных
* Ограничение на количество одновременных соединений на домен, что приводит к head-ofline блокировке (HOL).
* Оверхед заголовков: Повторение заголовков в каждом запросе и ответе приводит к дополнительным накладным расходам.

#### HTTP/ 2.2
* Бинарный протокол
* Мультикомплексирование - одно соединение обслуживает несколько одновременных запросов, что устраняет HOL блокировку
* Сжатие заголовков: Использование HPACK для сжатия заголовков, что уменьшает объем передаваемых данных.
* Серверные push-уведомления: Сервер может отправлять данные клиенту без явного запроса, что ускоряет загрузку страницы.
* Приоритетность запросов: Клиент может задавать приоритеты для запросов, что позволяет оптимизировать использование пропускной способности сети.
* Уменьшение задержек: Параллельная передача данных через одно соединение уменьшает задержки, связанные с установлением новых соединений.
* Совместимость: Некоторые старые системы и сети могут не поддерживать HTTP/2.

### Протоколы транспортного уровня: TCP, UDP
#### TCP
* Особенности
  * Надежсность -  Обеспечивает доставку данных в правильной последовательности и без потерь.
  * Установление соединения: Использует трехэтапный процесс установления соединения (3- way -handshake)
  * Контроль перегрузки и потоков: Управляет потоком данных и контролирует перегрузки сети.
* Использование
  *  Подходит для приложений, требующих надежной передачи данных, таких как веб-браузинг, email, FTP.
#### UDP
 * Особенности
   * Без установления соединения: Не требует предварительного установления соединения.
   * Низкая задержка: Быстрая передача данных без контроля перегрузок и повторных передач.
   * Потеря пакетов: Возможна потеря пакетов и неправильный порядок их доставки.
* Использование
    *  Подходит для приложений, где важнее скорость, а не надежность, таких как онлайн-игры, VoIP, стриминг.

# Тестирование

### Что такое unit-тестирование и какова его цель? 
Unit-тестирование (модульное тестирование) — это метод тестирования программного обеспечения, при котором отдельные компоненты или модули программы проверяются на правильность работы. 
#### Цель
* Найти дефекты в компонентах (классы/модули/функции)
* Сформировать уверенность (на каком-то уровне), что компонент работает
* Заложить базу для следующих уровней тестирования
#### На вход
* Код
* Модель данных, спецификация, описание компонента…
#### Объекты тестирования
* Классы
* Компоненты, модули
#### Типичные ошибки / дефекты
* Проблемы с потоком данных и потоком управления
* Неверная логика
* Не вписываемые требования

### Как создать и запустить простой unit-тест с использованием JUnit? Что такое аннотация @Test? Какие аннотации JUnit можно использовать при написании тестов? Приведите примеры.
#### Как создать и запустить простой unit-тест с использованием JUnit?
* Добавить зависимости в Pom.xlm 
```
<dependency> 
  <groupId>org.junit.jupiter</groupId> 
  <artifactId>junit-jupiter-engine</artifactId> 
  <version>5.10.0</version>
  <scope>test</scope>
</dependency>
```
* Создать тестовый класс в папке src/test/...
* Использовать аннотацию @Test для пометки тестовых методов, которая позволяет при запуске провести данный тест 
* Запустить тесты с помощью JUnit Runner
#### Какие аннотации JUnit можно использовать при написании тестов?
* @BeforeEach - позволяет выполнить функцию перед каждым тестом. применяется для сброса параметров, если они изменяются в проверяемой функции
* @AfterEach -  то же самое, только после каждого теста.
* @BeforeClass -  выполняется один раз перед всеми тестами.
* @AfterClass -  выполняется один раз после всех тестов.
* @Order - по порядку

### Какие проблемы решает Mockito при написании тестов? Как использовать Mockito для создания mock-объектов? Приведите примеры.
#### Какие проблемы решает Mockito при написании тестов?
* Сложность управления состоянием объекта: Мок-объекты можно легко настроить, чтобы возвращать определенные значения или вызывать конкретные методы, что упрощает управление состоянием объекта.
* Зависимость от сторонних объектов: Mockito позволяет создавать мок-объекты, которые имитируют поведение реальных объектов, устраняя зависимость от них.
* Проверка поведения объекта: Mockito позволяет проверять, какие методы вызывались на мок-объекте и с какими аргументами, что облегчает проверку правильности поведения объекта.
* Побочные эффекты реальных объектов: Использование мок-объектов изолирует тест от побочных эффектов реальных объектов, таких как запись в базу данных или отправка электронных писем.

### В чем разница между @Mock и @InjectMocks аннотациями в Mockito? Какие основные методы Mockito используются для задания поведения mock-объектов? 

#### Как использовать Mockito для создания mock-объектов? Приведите пример
* Для создания mock-объектов можно использовать аннотацию @Mock для объекта. 
К примеру мы тестируем сервис. Вешаем @Mock на репозиторий, который передает конструктор сервиса.
Для того чтобы внедрить зависимость, указываем аннотацию @InjectMock перд объявлением сервиса. А на методы вешаем аннотацию @Test

#### Основные методы Mockito для задания поведения mock-объектов
* when(...).thenReturn(...): Задает возвращаемое значение метода.
* when(...).thenThrow(...): Задает выбрасываемое исключение методом.
* doReturn(...).when(...): Альтернативный способ задания возвращаемого значения, используемый для void-методов или при необходимости задания поведения до вызова метода.
* doAnswer(...).when(...): Задает кастомное поведение метода.

### Что такое интеграционное тестирование? Объясните разницу между unit-тестами и интеграционными тестами.
* Интеграционное тестирование — это тип тестирования программного обеспечения, в котором отдельные модули или компоненты объединяются и тестируются как единая система. 
* Цель интеграционного тестирования — выявить дефекты, возникающие при взаимодействии между компонентами или системами, и убедиться, что они работают правильно вместе.
#### Разница между unit-тестами и интеграционными тестами
* Цель тестирования
  * Unit: Роверяют корректность рабты отдельных модулей или функций в изоляции от других чатсей системы
  * Интеграциооные тесты: Проверяют взаимодействие и интеграцию нескольких модулей или компонентов\
* Уровень изоляции
  * Unit-тесты: Высокий уровень изоляции. Тестируемый код изолирован от зависимостей с помощью mock-объектов или заглушек. 
  * Интеграционные тесты: Низкий уровень изоляции. Тестируемые модули взаимодействуют с реальными зависимостями или с частями системы, которые максимально приближены к реальным.
* Область покрытия
  * Unit-тесты: Покрывают небольшие части кода (отдельные методы или классы).
  * Интеграционные тесты: Покрывают взаимодействие между модулями, могут охватывать большие части системы.
* Пример
  * Unit-тесты: Проверка, что метод calculateSum() возвращает правильный результат.
  * Интеграционные тесты: Проверка, что модуль обработки платежей корректно взаимодействует с модулем базы данных и внешним API.
* Время выполнения 
  * Unit-тесты: Обычно выполняются быстро, так как изолированы и не требуют запуска всей системы.
  * Интеграционные тесты: Могут выполняться дольше, так как требуют настройки и взаимодействия с внешними системами или другими частями приложения.

### Инструменты для написания тестов: JUnit и Mockito
* JUnit — это фреймворк для написания и выполнения тестов на Java. Он предоставляет аннотации и утилиты для создания и управления тестовыми наборами, а также для выполнения тестов и проверки результатов.
  * Аннотации для тестов: определения тестовых методов (@Test), методов для подготовки (@Before, @BeforeClass), и очистки (@After, @AfterClass)
  * Ассерты: JUnit предоставляет множество утверждений (asserts) для проверки результатов тестов, таких как assertEquals(), assertTrue(), assertFalse(), assertNull(), и др.
  * Тестовые наборы: Возможность группировать тесты в наборы с помощью аннотации @Suite.
* Mockito — это фреймворк для создания mock-объектов в Java. Он позволяет изолировать тестируемый код от его зависимостей, заменяя реальные зависимости mock-объектами, которые можно настраивать и проверять.
  *  Создание mock-объектов: Создание объектов-заглушек для зависимостей
  * Задание поведения: С помощью методов when(), thenReturn(), thenThrow().
  * Проверка взаимодействий: С помощью метода verify().

# Безопасность

### Дайте определение понятиям идентификации, аутентификации и авторизации. В чем различие между ними?
* Идентификация – это процедура распознавания пользователя по его личному идентификатору. (Кто пользователь?)
* Аутентификация – процедура проверки подлинности, например: проверка подлинности пользователя путём сравнения введённого им пароля с паролем, сохранённым в базе данных пользовательских логинов. (Действительно ли это наш пользователь?)
* Авторизация – предоставление определённому лицу или группе лиц прав на выполнение определённых действий; а также процесс проверки данных прав при попытке выполнения этих действий. (К чему есть доступ у этого пользователя?)

### Что такое password-based authentication и какие у нее есть преимущества и недостатки? Объясните, как работает протокол HTTP Basic Authentication.
 * Метод аутентификации, который основывается на том, что пользователь должен предоставить логин и пароль для идентификации, а далее для аутентификации. 
 * Логин и пароль задаются пользователем при регистрации в системе.
 * Для аутентификации по паролю существуют протоколы, о которых поговорим дальше
##### Преимущества 
* Простота реализации
##### Недостатки
* Уязвимость к атакам типа brute force.
* Требует надежного хранения паролей.

#### Для чего используется протокол HTTP Authentication
* Фреймворк реализующий схему аутентификации вызов-ответ (challenge-response), для которой характерно до начала процесса аутентификации получение клиентом какой-то информации от сервера, а позже отправки данных для аутентификации в зашифрованном (но только не для базовой схемы) виде. 
Как это работает:
  * Клиент хочет аутентифицироваться (отправляет GETзапрос)
  * Сервер отвечает с кодом ошибки 401 (Unathorized), а также отправляет какую-то информацию, необходимую (возможно) для аутентификации в response header-e WWWW Authenticate
  * Клиент отправляет на сервер запрос с request header-ом Authorization (в котором находятся необходимые для авторизации данные)\
  * 
Существует всего несколько мест, где можно передать username и password в HTTP запросах: 
* 1.URL query — считается небезопасным вариантом, т. к. строки URL могут запоминаться браузерами, прокси и веб-серверами. 2.Request body — безопасный вариант, но он применим только для запросов, содержащих тело сообщения (такие как POST, PUT, PATCH). 3.HTTP header —оптимальный вариант, при этом могут использоваться и стандартный заголовок Authorization (например, с Basic-схемой), и другие произвольные заголовки.

### Что такое аутентификация по токенам? Приведите пример flow такого способа аутентификации.
* Протокол, который позволяет пользователям подтвердить свою личность, а в ответ получить уникальный токен доступа. В течение срока действия токена пользователи получают доступ к веб-сайту или приложению, для которого был выпущен токен, а не вводят учетные данные каждый раз, когда возвращаются на ту же веб-страницу, приложение или любой ресурс, защищенный этим же токеном.

### Объясните, что такое Single Sign-On (SSO) и в чем его преимущества.
* Технология единого входа (Single sign-on SSO) — метод аутентификации, который позволяет пользователям безопасно аутентифицироваться сразу в нескольких приложениях и сайтах, используя один набор учетных данных. \
  SSO базируется на настройке доверительных отношений между приложением, известным как провайдер услуг, и системой управления доступами.

##### Преимущества
* Удобно для пользователей
* Снижение числа учетных записей и паролей.
* Повышенная безопасность за счет центрального управления доступом.

### Что такое JSON Web Token? Из каких основных частей формируется данный токен
* JSON Web Token (JWT) — содержит три блока, разделенных точками: заголовок, набор полей (claims) и подпись. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие). Подпись может генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.

* Пример
  * { «alg»: «HS256», «typ»: «JWT» }
  * { «iss»: «auth.myservice.com», «aud»: «myservice.com», «exp»: «1435937883», «userName»: «John Smith», «userRole»: «Admin» }.
  * S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY

### Объясните разницу между access-токенами и refresh-токенами (и id-токеном?). Как происходит обновление access-токена с использованием refresh-токена?

* Access-токен - это краткосрочный токен, который предоставляет доступ к защищенным ресурсам, таким как API. Он имеет ограниченный срок действия, обычно от нескольких минут до нескольких часов.
* Refresh-токен - это долгосрочный токен, который используется для получения нового access-токена после истечения срока его действия. Он обычно имеет более длительный срок действия, например, несколько недель или месяцев.
* ID токен (токен идентификации) - это тип access-токена, который содержит информацию о пользователе, такую как его идентификатор, имя и адрес электронной почты. Он используется для аутентификации пользователя и предоставления ему доступа к защищенным ресурсам.

##### Процесс обновления access-токена с использованием refresh-токена:
* Когда access-токен истекает, клиентское приложение отправляет запрос на сервер авторизации вместе с refresh-токеном.
* Сервер авторизации проверяет подлинность refresh-токена и, если он действителен, выдает новый accessтокен и, возможно, новый refresh-токен.
* Клиентское приложение получает новый access-токен и продолжает использовать его для доступа к защищенным ресурсам.

### Объясните, как работают фильтры безопасности (security filters) в Spring Security и приведите примеры их использования. Как настроить аутентификацию с использованием JWT в Spring Security?
* Фильтры безопасности (security filters) в Spring Security играют ключевую роль в обеспечении безопасности веб-приложений. Они перехватывают HTTP-запросы и ответы на различных стадиях обработки и выполняют такие задачи, как аутентификация, авторизация, регистрация событий и управление сессиями.
#### Основные фильтры безопасности
* SecurityContextPersistenceFilter: Управляет контекстом безопасности (SecurityContext), обеспечивая его сохранение и восстановление.
* UsernamePasswordAuthenticationFilter: Обрабатывает аутентификацию на основе имени пользователя и пароля.
* BasicAuthenticationFilter: Обрабатывает HTTP Basic аутентификацию.
* BearerTokenAuthenticationFilter: Обрабатывает аутентификацию с использованием Bearer токенов, таких как JWT.
* ExceptionTranslationFilter: Обрабатывает исключения безопасности и направляет их в соответствующий обработчик.
* FilterSecurityInterceptor: Выполняет авторизацию, проверяя доступ к защищенным ресурсам.

#### Пример их использования 
##### CustomHeaderFilter
* Фильтр, который проверяет наличие определенного HTTP заголовка (X-Custom-Header) во входящих запросах.
* Пример использования: Обеспечение безопасности приложения путем требования специфического заголовка от клиентов перед выполнением других операций.
##### JwtTokenFilter 
* Фильтр, который проверяет JWT токен в заголовке Authorization каждого запроса.
* Пример использования: Обеспечение аутентификации пользователей по JWT токенам без использования сессий, что повышает безопасность и масштабируемость приложения.
####  Как настроить аутентификацию с использованием JWT в Spring Security?
* Создание JWT токена: JwtTokenProvider создает JWT токен с использованием ключа подписи и времени действия. Можно создать с помощью библиотеки io.jsonwebtoken
* JWT фильтр для аутентификации: JwtTokenFilter проверяет наличие и валидность JWT токена в каждом HTTP запросе, извлекает информацию о пользователе и устанавливает аутентификацию в контексте Spring Security.
  * Для обработки JWT токенов в каждом HTTP запросе вам нужно создать фильтр, который будет проверять наличие и валидность JWT токена в заголовке Authorization.
* Конфигурация Spring Security: В SecurityConfig регистрируется JwtTokenFilter в цепочке фильтров Spring Security и настраиваются правила доступа для различных URL в вашем приложении.
##### Заключение
 * Фильтры безопасности в Spring Security обеспечивают гибкий и мощный механизм для управления доступом и защитой вашего приложения. Настройка аутентификации с использованием JWT включает создание пользовательских фильтров для обработки токенов и их интеграцию в цепочку фильтров безопасности.